---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
library(Cardinal)
library(ggplot2)
```

# Data import 

```{r load-analyze-files}
TMA1 <- readImzML("TMA1.imzML")
TMA2 <- readImzML("TMA2.imzML")
```

#plot(TMA1, mz=1000.5, tolerance=0.1)

~/Downloads/Capstone_project/dataset

```{r viz_analyze_files}
TMA1 
TMA2 
```

```{r load-spectra-annotations}
TMA1_annotations <- read.delim("TMA1_annotations.txt", header = TRUE, stringsAsFactors = FALSE)
TMA2_annotations <- read.delim("TMA2_annotations.txt", header = TRUE, stringsAsFactors = FALSE)

```


```{r vis_spectra_annotations}

head(TMA1_annotations)
head(TMA2_annotations)

```


```{r}
library(dplyr)

plot_tissue_info <- function(annotations, plot_type = "diagnosis") {
  # Ensure annotations are ordered correctly
  annotations <- annotations %>% arrange(y, x)
  
  # Create the plot data
  plot_data <- annotations %>%
    select(x, y, diagnosis, histology, invasiveness)
  
  # Determine fill based on plot type
  fill_var <- sym(plot_type)
  fill_label <- capitalize(plot_type)
  
  # Create the plot
  ggplot(plot_data, aes(x = x, y = y, fill = !!fill_var)) +
    geom_tile() +
    scale_fill_viridis_d() +
    theme_minimal() +
    labs(title = paste("Tissue", fill_label),
         x = "X coordinate",
         y = "Y coordinate",
         fill = fill_label) +
    coord_fixed(ratio = 1) +  # This ensures squares are square
    theme(legend.position = "right")
}

# Helper function to capitalize first letter
capitalize <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}

# Plot for TMA1
plot_tissue_info(TMA1_annotations, "diagnosis")
plot_tissue_info(TMA1_annotations, "histology")
plot_tissue_info(TMA1_annotations, "invasiveness")

# Plot for TMA2
plot_tissue_info(TMA2_annotations, "diagnosis")
plot_tissue_info(TMA2_annotations, "histology")
plot_tissue_info(TMA2_annotations, "invasiveness")

```


## Smooth tissue images

## the next two code has been implement down the page 
```{r}

#smooth_TMA1 <- smooth(TMA1, method="gaussian", width=3)
#plot(smooth_TMA1, mz=1000.5, tolerance=0.1)

```

```{r}
#smooth_TMA2 <- smooth(TMA2, method="gaussian", width=3)
#plot(smooth_TMA1, mz=1000.5, tolerance=0.1)
# For PNG format
#png("smoothed_TMA2_plot.png", width=800, height=600)  # Width and height in pixels
```
 

a. Generate single m/z images:
```{r}

# For TMA1
plot(TMA1, mz=1000.5, tolerance=0.1)

# For TMA2
#plot(TMA2, mz=1000.5, tolerance=0.1)

```


```{r}
# Plot spectra from specific pixels
plot(TMA1, coord = list(c(75, 60), c(100, 80)))
```


```{r} 
#### not working review later

# library(Cardinal)
# library(ggplot2)
# library(dplyr)

# # Helper function
# capitalize <- function(x) {
#   substr(x, 1, 1) <- toupper(substr(x, 1, 1))
#   x
# }

# # Define the plot_overlay function
# plot_overlay <- function(msi_data, annotations, mz_value, tolerance = 0.1, plot_type = "diagnosis") {
#   # Extract coordinates and intensities
#   coords <- coord(msi_data)
#   mz_index <- which.min(abs(mz(msi_data) - mz_value))
#   intensities <- iData(msi_data, mz=mz_index)
  
#   # Ensure annotations are ordered correctly
#   annotations <- annotations[order(annotations$y, annotations$x), ]
  
#   # Combine data
#   plot_data <- data.frame(
#     x = coords$x,
#     y = coords$y,
#     intensity = intensities,
#     diagnosis = annotations$diagnosis,
#     histology = annotations$histology,
#     invasiveness = annotations$invasiveness
#   )
  
#   # Determine fill based on plot type
#   fill_var <- plot_data[[plot_type]]
#   fill_label <- capitalize(plot_type)
  
#   # Create the plot
#   ggplot(plot_data, aes(x = x, y = y)) +
#     geom_tile(aes(fill = intensity)) +
#     geom_tile(aes(alpha = fill_var), fill = "red") +
#     scale_fill_viridis_c() +
#     scale_alpha_manual(values = c(0.2, 0.5)) +
#     theme_minimal() +
#     labs(title = paste("Tissue", fill_label, "Overlay (m/z", mz_value, ")"),
#          x = "X coordinate",
#          y = "Y coordinate",
#          fill = "Intensity",
#          alpha = fill_label) +
#     coord_fixed(ratio = 1) +
#     theme(legend.position = "right")
# }
```

```{r}

# Now try plotting for TMA2
# plot_overlay(TMA2, TMA2_annotations, mz_value = 1000.5, plot_type = "diagnosis")
# plot_overlay(TMA2, TMA2_annotations, mz_value = 1000.5, plot_type = "histology")
# plot_overlay(TMA2, TMA2_annotations, mz_value = 1000.5, plot_type = "invasiveness")
# ````

##This code creates two main functions:

## 1. `plot_tissue_info()`: This function visualizes the tissue information (diagnosis, histology, or invasiveness) without the ion image overlay.

## 2. `plot_overlay()`: This function creates an overlay of the tissue information on top of an ion image for a specified m/z value.

## You can run these functions for both TMA1 and TMA2 to generate the visualizations. Remember to adjust the `mz_value` in the overlay plots if you want to visualize different m/z peaks.

## To save the plots, you can use:


#ggsave("TMA1_diagnosis.png", width = 10, height = 8)
```


# Preparing raw and metadata

First we filter the annotation data to remove all spectra that are not part of tumor or stroma tissues.

```{r prepare-spectra-annotations}

# Keeping only spectra annotations with tumor or stroma annotation in each TMA
TMA1_tumor_stroma <- TMA1_annotations[TMA1_annotations$histology == "Stroma" | TMA1_annotations$histology == "Tumor",]
TMA2_tumor_stroma <- TMA2_annotations[TMA2_annotations$histology == "Stroma" | TMA2_annotations$histology == "Tumor",]

```


```{r metadata-filtering}
# Generation of a logical vector that indicates for each spectrum if it has a tumor / stroma annotation or not

# For TMA1
coord_TMA1 <- coord(TMA1)
coord_string_TMA1 <- paste(coord_TMA1$x, coord_TMA1$y, sep="_")
annotation_string_TMA1 <- paste(TMA1_tumor_stroma$x, TMA1_tumor_stroma$y, sep="_")
annotated_spectra_TMA1 <- coord_string_TMA1 %in% annotation_string_TMA1

# For TMA2
coord_TMA2 <- coord(TMA2)
coord_string_TMA2 <- paste(coord_TMA2$x, coord_TMA2$y, sep="_")
annotation_string_TMA2 <- paste(TMA2_tumor_stroma$x, TMA2_tumor_stroma$y, sep="_")
annotated_spectra_TMA2 <- coord_string_TMA2 %in% annotation_string_TMA2

```


# Filtering to keep only spectra that have a tumor / stroma annotation
```{r prepare-spectra-annotations}

# Filtering
# For TMA1
TMA1_ROIs <- subset(TMA1, annotated_spectra_TMA1)

# For TMA2
TMA2_ROIs <- subset(TMA2, annotated_spectra_TMA2)

```


```{r prepare-spectra-annotations}

print(TMA1_ROIs)
print(TMA2_ROIs)

```

```{r verify_content}

head(coord(TMA1_ROIs))
head(coord(TMA2_ROIs))

```


```{r Check_pixel_data}
head(pixelData(TMA1_ROIs))
head(pixelData(TMA2_ROIs))
```


```{r extract_intensity_for_data_further_analysis}

   intensities_TMA1 <- spectra(TMA1_ROIs)
   intensities_TMA2 <- spectra(TMA2_ROIs)
```


```{r visualize_mean_spectrum}

plot(TMA1_ROIs)

plot(TMA2_ROIs)
```



Then we attach the metadata to the raw data.

```{r attach-metadata}

# order spectra coordinates to have them in same order in MSI data and metadata
TMA1_annot_ordered <- TMA1_tumor_stroma[with(TMA1_tumor_stroma, order(y,x)), ]
TMA2_annot_ordered <- TMA2_tumor_stroma[with(TMA2_tumor_stroma, order(y,x)), ]


# check if coordinates order is the same
head(TMA1_annot_ordered)
head(pixelData(TMA1_ROIs))


head(TMA2_annot_ordered)
head(pixelData(TMA2_ROIs))
```


```{r}
# combine the additional metadata and the pixel data (pData) of the MSI data
TMA1_metadata <- cbind(as.data.frame(pixelData(TMA1_ROIs)), TMA1_annot_ordered[4:7])
TMA2_metadata <- cbind(as.data.frame(pixelData(TMA2_ROIs)), TMA2_annot_ordered[4:7])

# attach the metadata dataframe to the MSI data, this requires defining the coordinates and run in the PositionDataFrame, which is a special data frame that holds metadata directly attached to the MSI data

# Create PositionDataFrame for TMA1
pd <- PositionDataFrame(
     coord = TMA1_metadata[, c("x", "y")],
     run = TMA1_metadata$run,
     histology = TMA1_metadata$histology,
     diagnosis = TMA1_metadata$diagnosis,
     invasiveness = TMA1_metadata$invasiveness,
     patient = TMA1_metadata$patient
 )
 
# Check the structure of pd
 str(pd)
 
# Create PositionDataFrame for TMA2
pd2 <- PositionDataFrame(
     coord = TMA2_metadata[, c("x", "y")],
     run = TMA2_metadata$run,
     histology = TMA2_metadata$histology,
     diagnosis = TMA2_metadata$diagnosis,
     invasiveness = TMA2_metadata$invasiveness,
     patient = TMA2_metadata$patient
 )
# Check the structure of pd
 str(pd2)

```


```{r visualize_mean_spectrum}

pixelData(TMA1_ROIs)$patient <- TMA1_metadata$patient
pixelData(TMA2_ROIs)$patient <- TMA2_metadata$patient


# TMA1_metadata has the same order as pixelData(TMA1_ROIs)
pixelData(TMA1_ROIs)$histology <- TMA1_metadata$histology
pixelData(TMA2_ROIs)$histology <- TMA2_metadata$histology

# Verify that it's been added
head(pixelData(TMA1_ROIs)$histology)
head(pixelData(TMA2_ROIs)$histology)
```



To get an overview of the annotations, we visualize the spectra annotations of each file. 
```{r}
patients_plot = ggplot(as.data.frame(pixelData(TMA1_ROIs)), aes(x=x, y=y, fill=patient)) +
  geom_tile(height = 1, width=1, show.legend=FALSE) +
  coord_fixed() +
  ggtitle("Different patients") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(text=element_text(family="ArialMT", face="bold", size=12)) +
  scale_discrete_manual(aesthetics = c("colour", "fill"), 
                        values = colorRampPalette(c("hotpink", "plum", "plum4", "violet", "magenta", "magenta4", "mediumorchid3", "mediumorchid4", "purple", "purple4"))(19))

print(patients_plot)

# calculate mean x and mean y position for each patient tissue
coord_labels = aggregate(cbind(x,y) ~ patient, data=as.data.frame(pixelData(TMA1_ROIs)), mean, na.rm=TRUE, na.action="na.pass") 


# histology
# Color palette
col <- colorRampPalette(c("hotpink", "plum", "plum4", "violet", "magenta", "magenta4", "mediumorchid3", "mediumorchid4", "purple", "purple4"))(39)

# Create plot data
plot_data <- data.frame(
  x = pixelData(TMA1_ROIs)$x,
  y = pixelData(TMA1_ROIs)$y,
  histology = pixelData(TMA1_ROIs)$histology,
  run = pixelData(TMA1_ROIs)$run
)


# Histology plot
histology_plot <- ggplot(plot_data, aes(x = x, y = y, fill = histology)) +
  geom_tile() +
  scale_fill_manual(values = col[c(1, 20)]) +
  coord_fixed() +
  theme_minimal() +
  labs(title = "Tumor and stroma spectra")

print(histology_plot)

# Run plot
run_plot <- ggplot(plot_data, aes(x = x, y = y, fill = run)) +
  geom_tile() +
  scale_fill_manual(values = c("grey48", "grey30")) +
  coord_fixed() +
  theme_minimal() +
  labs(title = "TMA (Run)")

print(run_plot)
```





```{r Patient2_histology_run}


library(ggplot2)
library(dplyr)

# Histology plot using ggplot2
histology_data <- as.data.frame(pData(TMA2_ROIs)) %>%
  select(x, y, histology)

histology_plot <- ggplot(histology_data, aes(x = x, y = y, fill = histology)) +
  geom_tile() +
  scale_fill_manual(values = c("royalblue", "coral2")) +
  coord_fixed() +
  theme_minimal() +
  labs(title = "Tumor and stroma spectra") +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(family="ArialMT", face="bold", size=12))

print(histology_plot)

# Run plot using ggplot2
run_data <- as.data.frame(pData(TMA2_ROIs)) %>%
  select(x, y, run)

run_plot <- ggplot(run_data, aes(x = x, y = y, fill = run)) +
  geom_tile() +
  scale_fill_manual(values = c("grey48", "grey30")) +
  coord_fixed() +
  theme_minimal() +
  labs(title = "TMA (Run)") +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(family="ArialMT", face="bold", size=12))

print(run_plot)
                       
```


# Pre-processing

For classification, we need to split the data into a training and test data set. 
It is important that the same subjects (patients) are either present in the training or in the test group but not in both. 
For this dataset it means that tumor and stroma region of the same patient have to be in the same set. Ideally, the training and test dataset are independent. 
Even though the tissues in TMA1 and TMA2 were similarly handled and are from a single institute, they were at least measured in separated runs. 
Thus, we will use TMA1 and TMA2 as test and training set respectively in the classification. 
To borrow as little information as possible between the two datasets, we keep them separate during preprocessing and only transfer the m/z positions from TMA2 to TMA1. 

![Overview of the analysis worklow](SSC_WF_case_study3.png)

## Spectral processing and mass alignment

Pre-processing is performed in several steps in order to be able to visualize the intermediate results. 
First we perform spectra smoothing and baseline reduction, which is recommended for low mass resolution MALDI-TOF imaging data.

```{r pp-smoothing-baseline}
# For TMA1
library(Cardinal)

# Smoothing with adjusted parameters
TMA1_smoothed_blremoved <- smooth(TMA1_ROIs, method = "gaussian", sd = 2)

# Get the coordinates of the first spectrum
first_coord_TMA1 <- coord(TMA1_ROIs)[1, ]

# Plot before preprocessing
plot(TMA1_ROIs, coord=c(first_coord_TMA1$x, first_coord_TMA1$y))

# Plot after smoothing
plot(TMA1_smoothed_blremoved, coord=c(first_coord_TMA1$x, first_coord_TMA1$y))

# For TMA2
TMA2_smoothed_blremoved <- smooth(TMA2_ROIs, method = "gaussian", sd = 2)

# Get the coordinates of the first spectrum
first_coord_TMA2 <- coord(TMA2_ROIs)[1, ]

# Plot before preprocessing
plot(TMA2_ROIs, coord=c(first_coord_TMA2$x, first_coord_TMA2$y))

# Plot after smoothing
plot(TMA2_smoothed_blremoved, coord=c(first_coord_TMA2$x, first_coord_TMA2$y))
```

Next, we perform m/z alignment in order to remove m/z shifts between spectra. 

```{r pp-alignment}
# For TMA1
TMA1_smoothed <- smooth(TMA1, method="gaussian", width=3)
TMA1_processed <- process(TMA1_smoothed)

# For TMA2
TMA2_smoothed <- smooth(TMA2, method="gaussian", width=3)
TMA2_processed <- process(TMA2_smoothed)


#After processing, let's try to visualize the results:

# For TMA1
plot(TMA1_processed, mz=1000.5, tolerance=0.1, main="TMA1 Processed")

# For TMA2
plot(TMA2_processed, mz=1000.5, tolerance=0.1, main="TMA2 Processed")

```

# m/z Peak Alignment 
```{r}
# For TMA1
TMA1_peaks <- peakPick(TMA1_processed, method="mad")
TMA1_aligned <- peakAlign(TMA1_peaks, tolerance=200, units="ppm")

# For TMA2
TMA2_peaks <- peakPick(TMA2_processed, method="mad")
TMA2_aligned <- peakAlign(TMA2_peaks, tolerance=200, units="ppm")

# Plot results
plot(TMA1_aligned, mz=1000.5, tolerance=0.1, main="TMA1 Aligned")
plot(TMA2_aligned, mz=1000.5, tolerance=0.1, main="TMA2 Aligned")



```

## We visualize the success of the m/z alignment by plotting a few randomly chosen spectra before and afterwards for each TMA.


```{r vis-mz-align, warning=False }
# For TMA1
set.seed(123)  # for reproducibility
random_pixels_TMA1 <- sample(1:nrow(coord(TMA1_processed)), 6)

par(mfrow = c(2,1), xpd=FALSE)
plot(TMA1_processed, pixel=random_pixels_TMA1, xlim=c(1295, 1315), ylim=c(0,10),
     key=FALSE, superpose=TRUE, main="TMA1 before alignment", layout=c(2,1))
par(xpd=FALSE)
plot(TMA1_aligned, pixel=random_pixels_TMA1, xlim=c(1295, 1315), ylim=c(0,10),
     key=FALSE, superpose=TRUE, main="TMA1 after alignment", layout=NULL)

# For TMA2
random_pixels_TMA2 <- sample(1:nrow(coord(TMA2_processed)), 6)

par(mfrow = c(2,1), xpd=FALSE)
plot(TMA2_processed, pixel=random_pixels_TMA2, xlim=c(1295, 1315), ylim=c(0,45),
     key=FALSE, superpose=TRUE, main="TMA2 before alignment", layout=c(2,1))
par(xpd=FALSE)
plot(TMA2_aligned, pixel=random_pixels_TMA2, xlim=c(1295, 1315), ylim=c(0,45),
     key=FALSE, superpose=TRUE, main="TMA2 after alignment", layout=NULL)
```



## Then we perform mass re-calibration by using the same function with internal calibrants as a reference. The internal calibrants angiotensin (m/z 1296.69), substance P (m/z 1347.72), fibrinopeptide B (m/z 1570.68) were mixed with the matrix and thus equally distributed over the tissue. 805.42 is an autolysis peptide of trypsin that we include as well as trypsin was sprayed equally over the tissue section.


##check the size of data:
```{r}
print(object.size(TMA1_aligned), units = "Gb")
print(object.size(TMA2_aligned), units = "Gb")
```
c(805.42, 1296.69, 1347.72, 1570.68)

## process a subset of the data:
```{r}

library(Cardinal)
library(BiocParallel)

calibrant_mz <- c(805.42, 1296.69, 1347.72, 1570.68)

# Function to check and handle missing values
handle_missing_values <- function(data) {
  # Check for missing values in the domain
  if (any(is.na(mz(data)))) {
    cat("Found missing values in mz. Removing them...\n")
    valid_mz <- !is.na(mz(data))
    data <- data[,valid_mz]
  }
  
  # Check for missing values in the spectra
  if (any(is.na(spectra(data)))) {
    cat("Found missing values in spectra. Replacing with zeros...\n")
    spectra(data)[is.na(spectra(data))] <- 0
  }
  
  return(data)
}

# Function to process data in chunks with error handling
process_in_chunks <- function(data, chunk_size = 500) {
    result_list <- list()
    for (i in seq(1, nrow(coord(data)), by = chunk_size)) {
        end <- min(i + chunk_size - 1, nrow(coord(data)))
        cat(sprintf("Processing chunk %d to %d\n", i, end))
        
        tryCatch({
            chunk <- data[i:end,]
            chunk <- handle_missing_values(chunk)
            chunk_recalibrated <- chunk %>%
                mzAlign(ref = calibrant_mz, tolerance = 200, units = "ppm") %>%
                process()
            
            result_list[[length(result_list) + 1]] <- chunk_recalibrated
        }, error = function(e) {
            cat(sprintf("Error processing chunk %d to %d: %s\n", i, end, conditionMessage(e)))
            # Include the chunk without recalibration
            result_list[[length(result_list) + 1]] <- handle_missing_values(data[i:end,])
        })
        
        gc()  # Force garbage collection
    }
    
    # Combine results
    do.call(combine, result_list)
}

# Handle missing values in the entire dataset before chunking
TMA1_aligned <- handle_missing_values(TMA1_aligned)
TMA2_aligned <- handle_missing_values(TMA2_aligned)

# Process TMA1
TMA1_recalibrated <- process_in_chunks(TMA1_aligned)

# Save intermediate result
save(TMA1_recalibrated, file="TMA1_recalibrated.RData")

# Process TMA2
TMA2_recalibrated <- process_in_chunks(TMA2_aligned)

# Save intermediate result
save(TMA2_recalibrated, file="TMA2_recalibrated.RData")

# Continue with the rest of your processing steps...
# (Visualization, peak picking, filtering, normalization, etc.)

```


## process the data in batches:
```{r}
# For TMA1
TMA1_recalibrated_list <- list()
for(i in seq(1, ncol(TMA1_aligned), by=1000)) {
    end <- min(i+999, ncol(TMA1_aligned))
    TMA1_recalibrated_list[[length(TMA1_recalibrated_list) + 1]] <- recalibrate_batch(TMA1_aligned, i, end)
}

# For TMA2
TMA2_recalibrated_list <- list()
for(i in seq(1, ncol(TMA2_aligned), by=1000)) {
    end <- min(i+999, ncol(TMA2_aligned))
    TMA2_recalibrated_list[[length(TMA2_recalibrated_list) + 1]] <- recalibrate_batch(TMA2_aligned, i, end)
}

```


## combine the results:

```{r}
TMA1_recalibrated <- do.call(cbind, TMA1_recalibrated_list)
TMA2_recalibrated <- do.call(cbind, TMA2_recalibrated_list)

```



```{r, binning}
library(Cardinal)

# Skip recalibration and work directly with aligned data
# Bin the data at 1 m/z resolution
bin_width <- 1
mz_range <- range(mz(TMA1_aligned), mz(TMA2_aligned))
bin_breaks <- seq(floor(mz_range[1]), ceiling(mz_range[2]), by=bin_width)

# Function to bin and normalize data
bin_and_normalize <- function(data, breaks) {
  data %>%
    bin(breaks=breaks) %>%
    normalize(method="tic") %>%
    process()
}

# Process TMA1 in chunks
chunk_size <- 500
TMA1_chunks <- list()
for(i in seq(1, nrow(coord(TMA1_aligned)), by=chunk_size)) {
  end <- min(i + chunk_size - 1, nrow(coord(TMA1_aligned)))
  cat(sprintf("Processing TMA1 chunk %d to %d\n", i, end))
  chunk <- TMA1_aligned[i:end,]
  TMA1_chunks[[length(TMA1_chunks) + 1]] <- bin_and_normalize(chunk, bin_breaks)
  gc()  # Force garbage collection
}
TMA1_normalized <- Reduce(combine, TMA1_chunks)

# Process TMA2 in chunks
TMA2_chunks <- list()
for(i in seq(1, nrow(coord(TMA2_aligned)), by=chunk_size)) {
  end <- min(i + chunk_size - 1, nrow(coord(TMA2_aligned)))
  cat(sprintf("Processing TMA2 chunk %d to %d\n", i, end))
  chunk <- TMA2_aligned[i:end,]
  TMA2_chunks[[length(TMA2_chunks) + 1]] <- bin_and_normalize(chunk, bin_breaks)
  gc()  # Force garbage collection
}
TMA2_normalized <- Reduce(combine, TMA2_chunks)

# Save preprocessed data
save(TMA1_normalized, file="TMA1_preprocessed.RData")
save(TMA2_normalized, file="TMA2_preprocessed.RData")

# Create data frames for easier ML processing
create_df <- function(data) {
  df <- as.data.frame(spectra(data))
  colnames(df) <- (bin_breaks[-1] + bin_breaks[-length(bin_breaks)]) / 2
  df$x <- coord(data)$x
  df$y <- coord(data)$y
  return(df)
}

TMA1_df <- create_df(TMA1_normalized)
TMA2_df <- create_df(TMA2_normalized)

# Save these data frames for ML processing
save(TMA1_df, file="TMA1_df.RData")
save(TMA2_df, file="TMA2_df.RData")

```
